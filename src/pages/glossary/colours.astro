---
// filepath: c:\Users\Lenovo\OneDrive\Desktop\parixan\abcd\src\pages\glossary\colours.astro
import BaseLayout from "../../layouts/Base.astro"; 
import BackButton from "../../components/ui/backButton.astro";     
import "../../assets/styles/varnmala/greek-alphabet.css"; // General styles

// Define the type for our colour data entries
export interface ColourEntry {
  id: string;
  letter: string; 
  fullName: string;
  // imageUrl: string;
  cssColor: string; 
}

const pageTitle = "Colours";
// const category = "colours"; 

const coloursData: ColourEntry[] = [
  { id: "black",  letter: "‚¨õ", fullName: "Black (‡§ï‡§æ‡§≤‡§æ)", cssColor: "black" },
  { id: "white",  letter: "‚¨ú", fullName: "White (‡§∏‡§´‡§º‡•á‡§¶)", cssColor: "white" },
  { id: "red",    letter: "üü•", fullName: "Red (‡§≤‡§æ‡§≤)",    cssColor: "red" },
  { id: "green",  letter: "üü©", fullName: "Green (‡§π‡§∞‡§æ)",  cssColor: "green" },
  { id: "yellow", letter: "üü®", fullName: "Yellow (‡§™‡•Ä‡§≤‡§æ)", cssColor: "yellow" },
  { id: "blue",   letter: "üü¶", fullName: "Blue (‡§®‡•Ä‡§≤‡§æ)",   cssColor: "blue" },
  { id: "brown",  letter: "üü´", fullName: "Brown (‡§≠‡•Ç‡§∞‡§æ)",  cssColor: "brown" },
  { id: "orange", letter: "üüß", fullName: "Orange (‡§®‡§æ‡§∞‡§Ç‡§ó‡•Ä)",cssColor: "orange" },
  { id: "pink",   letter: "üíñ", fullName: "Pink (‡§ó‡•Å‡§≤‡§æ‡§¨‡•Ä)", cssColor: "pink" },
  { id: "purple", letter: "üü™", fullName: "Purple (‡§¨‡•à‡§Ç‡§ó‡§®‡•Ä)",cssColor: "purple" },
  { id: "gray",   letter: "ü©∂", fullName: "Gray (‡§∏‡•ç‡§≤‡•á‡§ü‡•Ä)", cssColor: "gray" }
];

// Helper function to parse English and Hindi names (only English part will be used for front)
function parseNames(fullName: string): { english: string; hindi: string } {
  const match = fullName.match(/^(.*?) \((.*?)\)$/);
  if (match && match.length === 3) {
    return { english: match[1].trim(), hindi: match[2].trim() };
  }
  // Fallback if parsing fails, attempt to extract English part
  const englishOnlyMatch = fullName.match(/^([a-zA-Z\s]+)/);
  if (englishOnlyMatch) {
    return { english: englishOnlyMatch[1].trim(), hindi: "" };
  }
  return { english: fullName, hindi: "" }; 
}
---

<BaseLayout meta={{ title: pageTitle }}>
  <article class="container__page alphabet-page-container">
    <div class="page-header">
      <BackButton href="/Glossary" />
      <h1 class="page-main-title">{pageTitle}</h1>
      <button id="flip-all-button-colours" class="flip__all__button">Flip All Cards</button>
    </div>

    <div class="grid-container alphabet-grid colours-grid">
      {
        coloursData.map((entry) => {
          const names = parseNames(entry.fullName);
          return (
            <div class="flip__card" data-id={entry.id}>
              <div class="flip__card__inner">
                <div class="card card__front">
                  <div class="flip__button">
                    {/* Modified flip button content */}
                    <span class="flip__button__text flip-text-label" title="Flip Card">Flip Card</span>
                    <span class="flip__button__text rotate-symbol-label is-hidden" title="Reset Card">&#x21bb;</span> {/* ‚Üª symbol */}
                  </div>
                  <div class="card-content-front">
                    <h2 class="text">{names.english}</h2>
                  </div>
                  <div class="card__glow"></div>
                </div>
                <div 
                  class="card card__back" 
                  style={`background: ${entry.cssColor || 'var(--background)'};`}
                >
                  <div class="flip__button">
                    {/* Modified flip button content */}
                    <span class="flip__button__text flip-text-label" title="Flip Card">Flip Card</span>
                    <span class="flip__button__text rotate-symbol-label is-hidden" title="Reset Card">&#x21bb;</span> {/* ‚Üª symbol */}
                  </div>
                  {/* No image or text on the back, just the color */}
                </div>
              </div>
            </div> 
          );
        })
      }
    </div>
  </article>

  <script>
    // Script for "Flip All Cards" button on the page
    const flipAllButtonPage = document.getElementById("flip-all-button-colours") as HTMLButtonElement | null;
    const pageFlipCards = document.querySelectorAll(".colours-grid .flip__card"); 
    let allFlippedStatus = false;

    if (flipAllButtonPage) {
      flipAllButtonPage.addEventListener("click", () => {
        allFlippedStatus = !allFlippedStatus;
        pageFlipCards.forEach((card) => {
          const flipCardElement = card as HTMLElement;
          if (allFlippedStatus) {
            flipCardElement.classList.add("flipped");
          } else {
            flipCardElement.classList.remove("flipped");
          }
          // Update text/icons for all buttons on this card based on new status
          const allButtonsOnThisCard = flipCardElement.querySelectorAll(".flip__button") as NodeListOf<HTMLElement>;
          allButtonsOnThisCard.forEach(btn => {
            const textLabel = btn.querySelector(".flip-text-label") as HTMLElement | null;
            const symbolLabel = btn.querySelector(".rotate-symbol-label") as HTMLElement | null;
            if (textLabel && symbolLabel) {
              if (allFlippedStatus) {
                textLabel.classList.add("is-hidden");
                symbolLabel.classList.remove("is-hidden");
              } else {
                textLabel.classList.remove("is-hidden");
                symbolLabel.classList.add("is-hidden");
              }
            }
          });
        });
        flipAllButtonPage.textContent = allFlippedStatus ? "Reset All Cards" : "Flip All Cards";
        flipAllButtonPage.classList.add("active");
        setTimeout(() => {
          if (flipAllButtonPage) { 
            flipAllButtonPage.classList.remove("active");
          }
        }, 300);
      });
    } else {
      console.warn("Page's Flip All button for colours not found.");
    }

    // Script for individual card interactions (mousemove and flip button)
    const cardsForMouseInteraction = document.querySelectorAll(".colours-grid .card"); 
    cardsForMouseInteraction.forEach((cardElement) => { 
      cardElement.addEventListener("mousemove", (e: Event) => {
        const htmlCardElement = cardElement as HTMLElement; 
        const rect = htmlCardElement.getBoundingClientRect();
        const event = e as MouseEvent;
        const x = ((event.clientX - rect.left) / htmlCardElement.clientWidth) * 100;
        const y = ((event.clientY - rect.top) / htmlCardElement.clientHeight) * 100;
        htmlCardElement.style.setProperty("--mouse-x", `${x}%`);
        htmlCardElement.style.setProperty("--mouse-y", `${y}%`);
      });
    });

    const individualFlipCards = document.querySelectorAll(".colours-grid .flip__card"); 
    individualFlipCards.forEach((card) => { // card is .flip__card
      const flipButtonsOnThisCard = card.querySelectorAll(".flip__button") as NodeListOf<HTMLElement>; // Gets buttons on front and back of this card

      flipButtonsOnThisCard.forEach((button) => { 
        button.addEventListener("click", (event) => {
          event.stopPropagation(); 
          card.classList.toggle("flipped"); // Toggle the card's class

          const isFlipped = card.classList.contains("flipped");
          
          // Update text/icons for all buttons on this card
          flipButtonsOnThisCard.forEach(btnInstance => {
            const textLabel = btnInstance.querySelector(".flip-text-label") as HTMLElement | null;
            const symbolLabel = btnInstance.querySelector(".rotate-symbol-label") as HTMLElement | null;
            if (textLabel && symbolLabel) {
              if (isFlipped) {
                textLabel.classList.add("is-hidden");
                symbolLabel.classList.remove("is-hidden");
              } else {
                textLabel.classList.remove("is-hidden");
                symbolLabel.classList.add("is-hidden");
              }
            }
          });
        });
      });
    });
  </script>
</BaseLayout>

<style is:global>
  /* Color variables and base styles */
  :root[data-theme="light"] {
    --primary: #007bff;
    --primary-light: #54aeff;
    --secondary: #6c757d;
    --text: #212529;
    --background: #ffffff;
    --border: #dee2e6;
    --character-gradient-start: var(--primary);
    --character-gradient-end: var(--primary-light);
    --character-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
  }

  :root[data-theme="dark"] {
    --primary: #0d6efd;
    --primary-light: #5fa2ff;
    --secondary: #adb5bd;
    --text: #f8f9fa;
    --background: #212529;
    --border: #495057;
    --character-gradient-start: hsl(211, 100%, 75%);
    --character-gradient-end: hsl(211, 100%, 85%);
    --character-shadow: 0 0 20px hsla(211, 100%, 75%, 0.2);
  }

  /* Styles for cards within .colours-grid */
  .colours-grid .flip__card {
    width: 100%;
    height: 100%;
    perspective: 1000px;
    min-height: 220px; /* Adjusted min-height */
  }
  
  .colours-grid .flip__card .card-content-front {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    height: 100%;
    text-align: center;
    padding: 1rem;
  }

  .colours-grid .flip__card .text { /* For the Colour Name on the front */
    font-size: 1.5rem; 
    font-weight: 700;
    color: var(--text); 
    margin: 0;
    transition: color 0.3s ease;
  }

  .colours-grid .flip__card .card {
    background: linear-gradient(145deg, var(--background), color-mix(in srgb, var(--background) 97%, var(--text) 3%));
    border-radius: 1.25rem;
    box-shadow:
      0 4px 15px rgba(0, 0, 0, 0.05),
      0 1px 2px rgba(0, 0, 0, 0.1);
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    display: flex; 
    flex-direction: column; 
    position: relative;
    overflow: hidden;
    border: 1px solid var(--border);
    backdrop-filter: blur(10px);
    width: 100%;
    height: 100%;
  }

  .colours-grid .flip__card .card:hover .card__glow {
    opacity: 1;
  }

  .colours-grid .flip__card .card.card__front:hover .text { 
    background: none;
    -webkit-background-clip: initial;
    background-clip: initial;
    color: var(--primary); 
  }

  .colours-grid .flip__card .flip__card__inner {
    width: 100%;
    height: 100%;
    text-align: left; 
    transition: transform 0.8s;
    transform-style: preserve-3d;
  }

  .colours-grid .flip__card .card__front,
  .colours-grid .flip__card .card__back {
    position: absolute;
    width: 100%;
    height: 100%;
    -webkit-backface-visibility: hidden;
    backface-visibility: hidden;
    top: 0;
    left: 0;
    display: flex; 
    justify-content: center; 
    align-items: center; 
  }

  .colours-grid .flip__card .card__back {
    padding: 0; 
    transform: rotateY(180deg);
    /* The background is now fully set by the inline style in the template.
       Ensure no other background properties here conflict. */
  }

  .colours-grid .flip__card.flipped .flip__card__inner {
    transform: rotateY(180deg);
  }

  .colours-grid .flip__card .flip__button {
    position: absolute;
    top: 0.75rem; 
    right: 0.75rem;
    z-index: 10; 
  }

  .colours-grid .flip__card .flip__button__text {
    font-size: 0.875rem;
    color: var(--secondary);
    padding: 0.35rem 0.75rem;
    background: color-mix(in srgb, var(--background) 97%, var(--text) 3%);
    border-radius: 2rem;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 1px solid var(--border);
    text-align: left;
  }

  .colours-grid .flip__card .flip__button__text:hover {
    background: var(--primary);
    color: var(--text-on-primary, #fff); 
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  }

  .is-hidden {
    display: none !important;
  }

  .colours-grid .flip__card .card__glow {
    position: absolute;
    inset: 0;
    background: radial-gradient(
      circle at var(--mouse-x, 50%) var(--mouse-y, 50%),
      color-mix(in srgb, var(--primary) 10%, transparent) 0%,
      transparent 60%
    );
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
  }

  @media (max-width: 768px) {
    .colours-grid .flip__card .text { 
      font-size: 1.25rem;
    }
  }

  .colours-grid.grid-container {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); 
    gap: 1rem; 
    padding: 1rem; 
  }
</style>