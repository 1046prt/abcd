---
import "@/assets/styles/kannada.css";
interface LetterPair {
  hindi: string;
  kannada: string;
  marathi: string;
  gujarati: string;
  punjabi: string;
  malayalam: string;
  bengali: string;
  assamese: string;
  manipuri: string; 
  english: string;
  type: "vowel" | "consonant" | "separator";
}

// Generate unicode characters for Hindi and Kannada
const generateLetters = (startCode: number, length: number, extraKeys: number[] = []): string[] =>
  Array.from({ length }, (_, i) => String.fromCodePoint(startCode + i)).filter(
    (_, index) => !extraKeys.includes(startCode + index)
  );

type GenerateAlphabetParams = {
  startCode: number;
  totalLength: number;
  extraKeys?: number[];
  insertEmptyAt?: number[]; // Indices to insert "಍"
  insertUnicodeAt?: { index: number; unicode: number }[]; // Indices to insert a specific Unicode character
};
/** 
 * @input generateAlphabets({ startCode: 2309, totalLength: 16 })
 * @output [ "अ", "आ", "इ", "ई", "उ", "ऊ", "ऋ", "ऌ", "ऍ", "ऎ", "ए", "ऐ", "ऑ", "ऒ", "ओ", "औ" ]
*/
const generateAlphabets = (params: GenerateAlphabetParams): string[] => {
  const {
    startCode,
    totalLength,
    extraKeys = [],
    insertEmptyAt = [],
    insertUnicodeAt = [] // Default to empty array if not provided
  } = params
  // Step 1: Generate the base characters after filtering out extraKeys
  const baseCharacters: string[] = [];
  for (let i = 0; i < totalLength; i++) {
    const codePoint = startCode + i;
    //excluding extra characters
    if (!extraKeys.includes(codePoint)) {
      baseCharacters.push(String.fromCodePoint(codePoint));
    }
  }
  // Step 2: Determine the maximum required length for the final array
  // Consider both insertEmptyAt and insertUnicodeAt for the maximum index
  const maxIndexInEmptyInserts = insertEmptyAt.length > 0 ? Math.max(...insertEmptyAt) : -1;
  const maxIndexInUnicodeInserts =
    insertUnicodeAt.length > 0 ? Math.max(...insertUnicodeAt.map((item) => item.index)) : -1;
  const finalLength = Math.max(baseCharacters.length, maxIndexInEmptyInserts + 1, maxIndexInUnicodeInserts + 1);
  // Step 3: Create the final result array, initially filled with "಍" (or a default empty string if you prefer)
  // Using "಍" as per your existing code's behavior for default fill.
  const result: string[] = Array(finalLength).fill("಍");
  // Step 4: Populate the result array
  let baseCharIndex = 0;
  for (let i = 0; i < finalLength; i++) {
    // Check for specific Unicode insertions first (highest priority)
    const unicodeToInsert = insertUnicodeAt.find((item) => item.index === i);
    if (unicodeToInsert) {
      result[i] = String.fromCodePoint(unicodeToInsert.unicode);
      continue; // Move to the next index after inserting a specific Unicode
    }
    // Check for empty string insertions (next priority)
    if (insertEmptyAt.includes(i)) {
      result[i] = "಍"; // Ensure it's "಍"
      continue; // Move to the next index
    }
    // Otherwise, insert a base character if available
    if (baseCharIndex < baseCharacters.length) {
      result[i] = baseCharacters[baseCharIndex];
      baseCharIndex++;
    }
    // If no specific insertion and no base character left, it remains "಍" from initial fill
  }
  return result;
};

// Updated English equivalents with more accurate transliterations
const englishVowels = ["a", "ā", "i", "ī", "u", "ū", "e", "ai", "o", "au", "aṃ", "aḥ"];
const englishConsonants = [
  "ka",
  "kha",
  "ga",
  "gha",
  "ṅa",
  "ca",
  "cha",
  "ja",
  "jha",
  "ña",
  "ṭa",
  "ṭha",
  "ḍa",
  "ḍha",
  "ṇa",
  "ta",
  "tha",
  "da",
  "dha",
  "na",
  "pa",
  "pha",
  "ba",
  "bha",
  "ma",
  "ya",
  "ra",
  "la",
  "va",
  "śa",
  "ṣa",
  "sa",
  "ha",
  "ḷa"
];

// Define allAlphabets structure
const allAlphabet = {
  vowels: {
    hindi: generateAlphabets({ startCode: 2309, totalLength: 16 }),
    kannada: generateAlphabets({ startCode: 3205, totalLength: 16 }),
    gujarati: generateAlphabets({startCode:2693,totalLength: 16}),
    punjabi: generateAlphabets({startCode:2565, totalLength:16}),
    malayalam: generateAlphabets({startCode:0xd05, totalLength:16,extraKeys: [0xd0d, 0xd11]}),
    bengali: generateAlphabets({startCode:0x985, totalLength:16, extraKeys: [0x98d, 0x991]}),
    assamese: generateAlphabets({startCode:0x985, totalLength: 16, extraKeys :[0x98d, 0x991]}),
    manipuri: generateAlphabets({startCode:0xabc0, totalLength: 8}),
    english: englishVowels // Directly use the array
  },
  consonants: {
    hindi: generateAlphabets({startCode:2325, totalLength: 37}),
    kannada: generateAlphabets({startCode:3221, totalLength: 37}),
    gujarati: generateAlphabets({startCode:0xa95, totalLength: 37}),
    punjabi: generateAlphabets({startCode:0xa15, totalLength: 37}),
    malayalam: generateAlphabets({startCode:0xd15, totalLength: 42}),
    bengali: generateAlphabets({startCode:0x995, totalLength: 37}),
    assamese: generateAlphabets({startCode:0x995, totalLength: 45}),
    manipuri: generateAlphabets({startCode:0xabd0, totalLength: 27}),
    english: englishConsonants // Directly use the array
  }
};

// Create letter pairs with all three scripts
const letterPairs: LetterPair[] = [
  ...allAlphabet.vowels.hindi.map((hindi, i) => ({
    hindi,
    marathi: allAlphabet.vowels.hindi[i], // Marathi shares Hindi vowels
    kannada: allAlphabet.vowels.kannada[i],
    gujarati: allAlphabet.vowels.gujarati[i],
    punjabi: allAlphabet.vowels.punjabi[i],
    malayalam: allAlphabet.vowels.malayalam[i],
    bengali: allAlphabet.vowels.bengali[i],
    assamese: allAlphabet.vowels.assamese[i],
    manipuri: allAlphabet.vowels.manipuri[i],
    english: allAlphabet.vowels.english[i],
    type: "vowel" as const
  })),
  ...allAlphabet.consonants.hindi.map((hindi, i) => ({
    hindi,
    marathi: allAlphabet.consonants.hindi[i], // Marathi shares Hindi consonants
    kannada: allAlphabet.consonants.kannada[i],
    gujarati: allAlphabet.consonants.gujarati[i],
    punjabi: allAlphabet.consonants.punjabi[i],
    malayalam:
      i < allAlphabet.consonants.malayalam.length ? allAlphabet.consonants.malayalam[i] : "",
    bengali: allAlphabet.consonants.bengali[i],
    assamese:
      i < allAlphabet.consonants.assamese.length ? allAlphabet.consonants.assamese[i] : "",
    manipuri:
      i < allAlphabet.consonants.manipuri.length ? allAlphabet.consonants.manipuri[i] : "",
    english: allAlphabet.consonants.english[i] || "",
    type: "consonant" as const
  }))
];

const languages = [
  { code: "PL", name: "Select Primary Language", disabled: true },
  { code: "hi", name: "hindi" },
  { code: "mr", name: "marathi" },
  { code: "kn", name: "kannada" },
  { code: "gu", name: "gujarati" },
  { code: "pa", name: "punjabi" },
  { code: "ml", name: "malayalam" },
  { code: "bn", name: "bengali" },
  { code: "as", name: "assamese" },
  { code: "mni", name: "manipuri" },
  { code: "en", name: "english" }
];
const languages2 = [
  { code: "SL", name: "Select Secondary Language", disabled: true },
  { code: "hi", name: "हिंदी" },
  { code: "mr", name: "मराठी" },
  { code: "kn", name: "ಕನ್ನಡ" },
  { code: "gu", name: "ગુજરાતી" }, 
  { code: "pa", name: "ਪੰਜਾਬੀ" }, 
  { code: "ml", name: "മലയാളം" }, 
  { code: "bn", name: "বাংলা" }, 
  { code: "as", name: "অসমীয়া" }, 
  { code: "mni", name: "ꯃꯤꯇꯩꯂꯣꯟ" },
  { code: "en", name: "english" }
];
let selectedLanguage1 = "hi";
let selectedLanguage2 = "kn";

const getLetterForLanguage = (pair: LetterPair, langCode: string): string => {
  switch (langCode) {
    case "hi":
      return pair.hindi;
    case "mr":
      return pair.marathi;
    case "kn":
      return pair.kannada;
    case "gu":
      return pair.gujarati;
    case "pa":
      return pair.punjabi;
    case "ml":
      return pair.malayalam;
    case "bn":
      return pair.bengali;
    case "as":
      return pair.assamese;
    case "mni":
      return pair.manipuri;
    case "en":
      return pair.english;
    default:
      return "";
  }
};
---
<div class="language-letters-container">
  <div class="main-header">  
  <div class="toggle-container">
    <div class="dropdown-wrapper">
      <label id="lang1Label" class="dropdown-label language-label active"> PRIMARY LANGUAGE </label>
      <select id="languageDropdown1">
        {
          languages.map((lang) => (
            <option
              class="opt"
              value={lang.code}
              selected={lang.code === selectedLanguage1}
              disabled={lang.disabled ? "disabled" : null}
            >
              {lang.name}
            </option>
          ))
        }
      </select>
    </div>
    <button id="toggleButton" class="toggle-button" aria-label="Swap languages" title="Swap languges">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24">
        <path d="M17 14 9 14 9 16 17 16 17 19 22 15 17 11 17 14z"></path><path
          d="M15 10 15 8 7 7 7 5 2 9 7 13 7 10 15 10z"></path>
      </svg>
    </button>

    <div class="dropdown-wrapper">
      <label id="lang2Label" class="dropdown-label language-label"> SECONDARY LANGUAGE </label>
      <select id="languageDropdown2">
        {
          languages2.map((lang) => (
            <option
              class="opt"
              value={lang.code}
              selected={lang.code === selectedLanguage2}
              disabled={lang.disabled ? "disabled" : null}
            >
              {lang.name}
            </option>
          ))
        }
      </select>
    </div>
  </div>
</div>
  <!-- Letters Grid Section -->
  <div class="language-letters-grid">
    <h2 class="group-heading" style="grid-column: 1 / -1;">VOWELS</h2>
    {
      letterPairs
        .filter((pair) => pair.type === "vowel")
        .map((pair, index) => (
          <div data-key={`vowel-${index}`} class="language-letter-card language-letter-card-vowel">
            <div class="language-letter-top">{getLetterForLanguage(pair, selectedLanguage1)}</div>
            <div class="language-letter-bottom">{getLetterForLanguage(pair, selectedLanguage2)}</div>
          </div>
        ))
    }

    <div class="language-letters-separator" style="grid-column: 1 / -1;"></div>


    <h2 class="group-heading" style="grid-column: 1 / -1;">CONSONANTS</h2>
    {
      letterPairs
        .filter((pair) => pair.type === "consonant")
        .map((pair, index) => (
          <div data-key={`consonant-${index}`} class="language-letter-card language-letter-card-consonant">
            <div class="language-letter-top">{getLetterForLanguage(pair, selectedLanguage1)}</div>
            <div class="language-letter-bottom">{getLetterForLanguage(pair, selectedLanguage2)}</div>
          </div>
        ))
    }
  </div>
  <!-- OM -->
<div id="letterPopup" class="letter-popup">
  <div class="outer">
    <button id="closePopup" class="close-button">×</button>
    <div class="middle">
    <div class="popup-content">
    <div class="popup-letter"> ॐ</div>
  </div>
    </div>
</div>
</div>
  </div>
<script type="module" is:inline>
  // Letter generation helpers
  const generateLetters = (startCode, length, extraCodes = []) =>
    Array.from({ length }, (_, i) => String.fromCodePoint(startCode + i)).filter(
      (_, i) => !extraCodes.includes(startCode + i)
    );
  /**
   * @typedef {object} GenerateAlphabetParams
   * @property {number} startCode
   * @property {number} totalLength
   * @property {number[]} [extraKeys] - Optional. Unicode code points to exclude from the generated sequence.
   * @property {number[]} [insertEmptyAt] - Optional. Indices to insert "಍" (empty string in your context, but represented as '಍').
   * @property {{ index: number; unicode: number }[]} [insertUnicodeAt] - Optional. Indices to insert a specific Unicode character.
   */
  /**
   * Generates an array of characters based on a starting Unicode code, total length,
   * and allows for filtering specific characters and inserting placeholders or custom Unicode characters at given indices.
   *
   * @param {GenerateAlphabetParams} params - The parameters object.
   * @returns {string[]} An array of generated characters.
   */
  const generateAlphabets = (params) => {
    const { startCode, totalLength, extraKeys = [], insertEmptyAt = [], insertUnicodeAt = [] } = params;

    // Step 1: Generate the base characters after filtering out extraKeys
    const baseCharacters = [];
    for (let i = 0; i < totalLength; i++) {
      const codePoint = startCode + i;
      if (!extraKeys.includes(codePoint)) {
        baseCharacters.push(String.fromCodePoint(codePoint));
      }
    }

    // Step 2: Determine the maximum required length for the final array
    // Consider both insertEmptyAt and insertUnicodeAt for the maximum index
    const maxIndexInEmptyInserts = insertEmptyAt.length > 0 ? Math.max(...insertEmptyAt) : -1;
    const maxIndexInUnicodeInserts =
      insertUnicodeAt.length > 0 ? Math.max(...insertUnicodeAt.map((item) => item.index)) : -1;

    const finalLength = Math.max(baseCharacters.length, maxIndexInEmptyInserts + 1, maxIndexInUnicodeInserts + 1);

    // Step 3: Create the final result array, initially filled with "಍"
    const result = Array(finalLength).fill("಍");

    // Step 4: Populate the result array
    let baseCharIndex = 0;

    for (let i = 0; i < finalLength; i++) {
      // Check for specific Unicode insertions first (highest priority)
      const unicodeToInsert = insertUnicodeAt.find((item) => item.index === i);
      if (unicodeToInsert) {
        result[i] = String.fromCodePoint(unicodeToInsert.unicode);
        continue; // Move to the next index after inserting a specific Unicode
      }

      // Check for empty string insertions (next priority)
      if (insertEmptyAt.includes(i)) {
        result[i] = "಍"; // Ensure it's "಍"
        continue; // Move to the next index
      }

      // Otherwise, insert a base character if available
      if (baseCharIndex < baseCharacters.length) {
        result[i] = baseCharacters[baseCharIndex];
        baseCharIndex++;
      }
      // If no specific insertion and no base character left, it remains "಍" from initial fill
    }

    return result;
  };

  // Use correct English transliterations instead of just basic letters
  const englishVowels = ["a", "ā", "i", "ī", "u", "ū", "e", "ai", "o", "au", "aṃ", "aḥ"];
  const englishConsonants = [
    "ka",
    "kha",
    "ga",
    "gha",
    "ṅa",
    "ca",
    "cha",
    "ja",
    "jha",
    "ña",
    "ṭa",
    "ṭha",
    "ḍa",
    "ḍha",
    "ṇa",
    "ta",
    "tha",
    "da",
    "dha",
    "na",
    "nna", // This 'nna' seems to be an addition. Review if it should be present.
    "pa",
    "pha",
    "ba",
    "bha",
    "ma",
    "ya",
    "ra",
    "rra", // This 'rra' seems to be an addition. Review if it should be present.
    "la",
    "va",
    "śa",
    "va", // Duplicate 'va'?
    "sha",
    "sha", // Duplicate 'sha'?
    "sa",
    "ha",
    "kṣa",
    "ha" // Duplicate 'ha'?
  ];

  // Restructured allAlphabets object
  const allAlphabet = {
    vowels: {
      hindi: generateAlphabets({ startCode: 2309, totalLength: 16 }),
      kannada: generateAlphabets({ startCode: 3205, totalLength: 16 }),
      gujarati: generateAlphabets({startCode:2693,totalLength: 16}),
      punjabi:generateAlphabets({startCode:2565, totalLength:16}),
      malayalam: generateAlphabets({startCode:0xd05,totalLength: 16, extraKeys: [0xd0d, 0xd11]}),
      bengali: generateAlphabets({startCode:0x985,totalLength:  16, extraKeys: [0x98d, 0x991]}),
      assamese: generateAlphabets({startCode:0x985, totalLength: 16, extraKeys: [0x98d, 0x991]}),
      manipuri: generateAlphabets({startCode:0xabc0, totalLength: 8}),
      english: englishVowels
    },
    consonants: {
      hindi: generateAlphabets({startCode:2325,totalLength : 37}),
      kannada: generateAlphabets({startCode:3221,totalLength : 37}),
      gujarati: generateAlphabets({startCode:0xa95,totalLength : 37}),
      punjabi: generateAlphabets({startCode:0xa15,totalLength : 37}),
      malayalam: generateAlphabets({startCode:0xd15,totalLength : 42}),
      bengali: generateAlphabets({startCode:0x995,totalLength : 37}),
      assamese: generateAlphabets({startCode:0x995,totalLength : 45}),
      manipuri: generateAlphabets({startCode:0xabd0,totalLength : 27}),
      english: englishConsonants
    }
  };

  const languages = [
    { code: "hi", name: "hindi" },
    { code: "mr", name: "marathi" },
    { code: "kn", name: "kannada" },
    { code: "gu", name: "gujarati" },
    { code: "pa", name: "punjabi" },
    { code: "ml", name: "malayalam" },
    { code: "bn", name: "bengali" },
    { code: "as", name: "assamese" },
    { code: "mni", name: "manipuri" },
    { code: "en", name: "english" }
  ];

  let selectedLanguage1 = "hi";
  let selectedLanguage2 = "kn";
  let isReversed = false;

  function getLetter(langCode, type, index) {
    // Find the language object from the `languages` array
    const langObj = languages.find((lang) => lang.code === langCode);

    // If language object is not found, return an empty string
    if (!langObj) {
      return "";
    }

    const languageName = langObj.name; // Get the full language name (e.g., "hindi", "kannada")

    if (type === "vowel") {
      // Handle Marathi separately as it shares Hindi vowels
      if (langCode === "mr") {
        return allAlphabet.vowels.hindi[index] || "";
      }
      // Use the languageName to access the correct array in allAlphabets.vowels
      return allAlphabet.vowels[languageName]?.[index] || "";
    } else if (type === "consonant") {
      // Handle Marathi separately as it shares Hindi consonants
      if (langCode === "mr") {
        return allAlphabet.consonants.hindi[index] || "";
      }
      // Use the languageName to access the correct array in allAlphabets.consonants
      return allAlphabet.consonants[languageName]?.[index] || "";
    }
    return "";
  }

  // Main function to swap languages
  function swapLanguages() {
    // Swap the language variables
    [selectedLanguage1, selectedLanguage2] = [selectedLanguage2, selectedLanguage1];

    // Update the dropdown values
    document.getElementById("languageDropdown1").value = selectedLanguage1;
    document.getElementById("languageDropdown2").value = selectedLanguage2;
    // Refresh the grid
    updateGrid();
    // Toggle persistent state
    const button = document.getElementById("toggleButton");
    button.classList.toggle("toggled");
    // Keep the animation
    button.classList.add("swapping");
    setTimeout(() => button.classList.remove("swapping"), 300);
    // Add visual feedback
    const toggleButton = document.getElementById("toggleButton");
    toggleButton.classList.add("swapping");
    setTimeout(() => {
      toggleButton.classList.remove("swapping");
    }, 300);
  }
  // Helper function to update language labels
  function updateGrid() {
    // Update all letter cards
    const vowelCards = document.querySelectorAll(".language-letter-card-vowel");
    const consonantCards = document.querySelectorAll(".language-letter-card-consonant");
    // Update vowels
    vowelCards.forEach((card, index) => {
      const topElement = card.querySelector(".language-letter-top");
      const bottomElement = card.querySelector(".language-letter-bottom");
      if (topElement && bottomElement) {
        topElement.textContent = getLetter(selectedLanguage1, "vowel", index);
        bottomElement.textContent = getLetter(selectedLanguage2, "vowel", index);
        // Add special styling for English text
        topElement.classList.toggle("english-text", selectedLanguage1 === "en");
        bottomElement.classList.toggle("english-text", selectedLanguage2 === "en");
        // Add transliteration class for proper display of diacritical marks
        topElement.classList.toggle("transliteration", selectedLanguage1 === "en");
        bottomElement.classList.toggle("transliteration", selectedLanguage2 === "en");
      }
    });
    // Update consonants
    consonantCards.forEach((card, index) => {
      const topElement = card.querySelector(".language-letter-top");
      const bottomElement = card.querySelector(".language-letter-bottom");
      if (topElement && bottomElement) {
        topElement.textContent = getLetter(selectedLanguage1, "consonant", index);
        bottomElement.textContent = getLetter(selectedLanguage2, "consonant", index);
        // Add special styling for English text
        topElement.classList.toggle("english-text", selectedLanguage1 === "en");
        bottomElement.classList.toggle("english-text", selectedLanguage2 === "en");
        // Add transliteration class for proper display of diacritical marks
        topElement.classList.toggle("transliteration", selectedLanguage1 === "en");
        bottomElement.classList.toggle("transliteration", selectedLanguage2 === "en");
      }
    });
  }
  // Set up event listeners
  document.addEventListener("DOMContentLoaded", () => {
    const dropdown1 = document.getElementById("languageDropdown1");
    const dropdown2 = document.getElementById("languageDropdown2");
    const toggleButton = document.getElementById("toggleButton");
    // Get the popup elements
    const popup = document.getElementById("letterPopup");
    const closeButton = document.getElementById("closePopup");
    const mainHeader = document.querySelector(".main-header");
    const scrollThreshold = 50; // Pixels to scroll before the header shrinks
        function handleScroll() {
      if (window.scrollY > scrollThreshold) {
        mainHeader.classList.add("scrolled-header");
      } else {
        mainHeader.classList.remove("scrolled-header");
      }
    }

    // Initial check in case the page is loaded with a scroll position
    handleScroll();

    // Listen for scroll events
    window.addEventListener("scroll", handleScroll);

    // Event listeners
    dropdown1.addEventListener("change", (e) => {
      selectedLanguage1 = e.target.value;
      updateGrid();
    });
    dropdown2.addEventListener("change", (e) => {
      selectedLanguage2 = e.target.value;
      updateGrid();
    });
    // Add click handler for swap button
    toggleButton.addEventListener("click", swapLanguages);
    updateGrid();
        // Add click event to all letter cards
    const letterCards = document.querySelectorAll(".language-letter-card");
    letterCards.forEach(card => {
      card.addEventListener("click", () => {
        popup.style.display = "flex";
      });
    });
    // Close popup when close button is clicked
    closeButton.addEventListener("click", () => {
      popup.style.display = "none";
    });
        closeButton.addEventListener("click", () => {
      popup.style.display = "none";
    });
  });
</script>
